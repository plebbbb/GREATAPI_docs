
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Reference</title>

    <style media="screen">
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cpf {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s, .highlight .sa, .highlight .dl {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf, .highlight .fm {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv, .highlight .vm {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .nl {
  color: #f92672;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <style media="print">
      * {
        -webkit-transition:none!important;
        transition:none!important;
      }
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #586e75;
}
.highlight .err {
  color: #002b36;
  background-color: #dc322f;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cm, .highlight .cpf, .highlight .c1, .highlight .cs {
  color: #657b83;
}
.highlight .cp {
  color: #b58900;
}
.highlight .nt {
  color: #b58900;
}
.highlight .o, .highlight .ow {
  color: #93a1a1;
}
.highlight .p, .highlight .pi {
  color: #93a1a1;
}
.highlight .gi {
  color: #859900;
}
.highlight .gd {
  color: #dc322f;
}
.highlight .gh {
  color: #268bd2;
  background-color: #002b36;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #6c71c4;
}
.highlight .kc {
  color: #cb4b16;
}
.highlight .kt {
  color: #cb4b16;
}
.highlight .kd {
  color: #cb4b16;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .dl, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #859900;
}
.highlight .sa {
  color: #6c71c4;
}
.highlight .sr {
  color: #2aa198;
}
.highlight .si {
  color: #d33682;
}
.highlight .se {
  color: #d33682;
}
.highlight .nn {
  color: #b58900;
}
.highlight .nc {
  color: #b58900;
}
.highlight .no {
  color: #b58900;
}
.highlight .na {
  color: #268bd2;
}
.highlight .m, .highlight .mb, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mx {
  color: #859900;
}
.highlight .ss {
  color: #859900;
}
    </style>
    <link href="stylesheets/screen-c9d8fa83.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print-953e3353.css" rel="stylesheet" media="print" />
      <script src="javascripts/all-a9fde460.js"></script>

    <script>
      $(function() { setupCodeCopy(); });
    </script>
  </head>

  <body class="index" data-languages="[&quot;cpp&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar-cad8cdcb.png" alt="" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo-5cf4fa3a.png" class="logo" alt="" />
        <div class="lang-selector">
              <a href="#" data-language-name="cpp">cpp</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#introduction" class="toc-h1 toc-link" data-title="Introduction">Introduction</a>
          </li>
          <li>
            <a href="#installation" class="toc-h1 toc-link" data-title="Installation">Installation</a>
          </li>
          <li>
            <a href="#odometry" class="toc-h1 toc-link" data-title="Odometry">Odometry</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#rotational-odometry" class="toc-h2 toc-link" data-title="Rotational Odometry">Rotational Odometry</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#errors" class="toc-h1 toc-link" data-title="Errors">Errors</a>
          </li>
      </ul>
        <ul class="toc-footer">
            <li><a href='https://www.stlrobotics.org/'>Go to our website</a></li>
            <li><a href='https://github.com/slatedocs/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='introduction'>Introduction</h1>
<p>Welcome to GREATAPI, a Vex Robotics library for the PROS API. </p>
<h1 id='installation'>Installation</h1>
<p>To install GREATAPI, head to our <a href="https://github.com/plebbbb/GREATAPI/releases">releases page</a> and download the lastest GREATAPI@{something}.zip.</p>

<p>Open up a console on the folder you&#39;ve downloaded GREATAPI to, and enter the following command:</p>

<p><code>
prosv5 conduct fetch greatapi@[whatever version we are on].zip
</code></p>

<p>From here, GREATAPI should be addable on the upgrade tab of the PROS editor. You may have to manually type in the name for it to be detected. If GREATAPI isn&#39;t there, open up a console in the directory of your PROs project(the folder with project.pros) and enter the following:</p>

<p><code>
prosv5 conduct apply greatapi
</code></p>
<h1 id='odometry'>Odometry</h1>
<p>GREATAPI provides multiple feature levels of odometry for different robot configurations.</p>
<h2 id='rotational-odometry'>Rotational Odometry</h2>
<p>The lowest feature level GREATAPI provides is rotation tracking via the <code>odom_rotation</code> class.</p>

<p>Various tracking approaches are supported by child classes of <code>odom_rotation</code></p>

<table><thead>
<tr>
<th>Class Name</th>
<th>Utlized Sensors</th>
<th>Required Measurements</th>
</tr>
</thead><tbody>
<tr>
<td>IMU_odom_rotation</td>
<td>1x V5 Inertial Sensor</td>
<td>Inertial drift compensation multiplier</td>
</tr>
<tr>
<td>DoubleIMU_odom_rotation</td>
<td>2x V5 Inertial Sensor</td>
<td>none</td>
</tr>
<tr>
<td>TWheel_odom_rotation</td>
<td>2x Wheel encoders(any type)</td>
<td>Distance between wheel encoders, wheel diameters</td>
</tr>
</tbody></table>

<aside class = "warning">
<code>TWheel_odom_rotation</code> has unique and specific restrictions. Please go to its section for more details.
</aside>

<p><code>odom_rotation</code> child classes provide two functions for the end user:</p>

<table><thead>
<tr>
<th>Function</th>
<th>Purpose</th>
<th>Output</th>
</tr>
</thead><tbody>
<tr>
<td>get_heading()</td>
<td>Returns absolute heading of robot from starting position</td>
<td><code>SRAD</code> angle object</td>
</tr>
<tr>
<td>applyOffset(SRAD real)</td>
<td>Calibrates odometry output to match that of the real angle</td>
<td>nothing</td>
</tr>
</tbody></table>

<aside class = "warning"> Note that <code>odom_rotation</code> itself does not provide any angle calculation capabilities. Please construct one of the availiable child class options instead when programming your robot.
</aside>
<h3 id='imu_odom_rotation'>IMU_odom_rotation</h3>
<blockquote>
<p>Prototype</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code>  <span class="n">IMU_odom_rotation</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">double</span> <span class="n">driftcompensationfac</span><span class="p">)</span>
</code></pre></div>
<blockquote>
<p>Example</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code>  <span class="n">greatapi</span><span class="o">::</span><span class="n">odometry</span><span class="o">::</span><span class="n">IMU_odom_rotation</span> <span class="nf">example</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mf">1.01</span><span class="p">);</span> <span class="c1">//IMU on port 15, 101% drift compensation factor</span>
  <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
    <span class="n">SRAD</span> <span class="n">currentangle</span> <span class="o">=</span> <span class="n">example</span><span class="p">.</span><span class="n">get_heading</span><span class="p">();</span> <span class="c1">//get current heading</span>
    <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">currentangle</span><span class="p">);</span> <span class="c1">//print angle on terminal</span>
    <span class="n">pros</span><span class="o">::</span><span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//10ms delay</span>
  <span class="p">}</span>
</code></pre></div>
<blockquote>
<p>The v5 IMU has an update period of 10ms. Checking more frequently than that will not yield different results.</p>
</blockquote>

<p><code>IMU_odom_rotation</code> is a basic wrapper for the vex IMU. </p>

<p>It provides the capability to counteract integration drift via an automatic scaling the calculated angle by a specific amount. </p>
<h3 id='integration-drift'>Integration drift</h3>
<p>Integration drift is a phenomenon commonly found in inertial sensors. Inertial sensors measure the acceleration, and angular velocity of the robot at any point in time. To convert these values into more useful measurements like speed, heading, or position, we must use a technique known as integration. While we don&#39;t know where the robot actually is with these sensor values, we can assume that it starts at some fixed state(like not moving). From there, we can convert our accelerations and angular velocities into velocity, position, and heading changes. These can be added to the previous calculated position to get the current position.</p>

<p>There are two problems with this approach that form what we call integration drift.</p>

<ul>
<li>Inaccuracies cannot be removed, and can(and will) add up until the sensor is very inaccurate</li>
<li>The integration process of converting measurements upscales any sensor inaccuracies.

<ul>
<li>Incidentally, this is why most vex libraries don&#39;t provide the feature to calculate position using the IMU. To get position data, one needs to integrate twice(acceleration -&gt; velocity -&gt; position), greatly reducing accuracy. Heading data only needs one integration(angular velocity -&gt; heading), which isn&#39;t as brutal.</li>
</ul></li>
</ul>

<p>A quick and quite dirty way of compensating for this is to just scale the total degrees traveled by a hard set multiplier. One can experimentally determine a multiplier just by spinning the robot a known amount of degrees, and then dividing the known value by the sensor reported angle. Spinning over 10 rotations is suggested to minimize inaccuracy in determining the real traveled angle of the robot.</p>

<p>The multiplier is to be put in as the <code>driftcompensationfac</code> parameter of the constructor.</p>
<h3 id='doubleimu_odom_rotation'>DoubleIMU_odom_rotation</h3>
<p>Supposedly, there is a method of canceling out inertial drift with the same model of sensor by flipping one over and averaging out their outputs. Somehow, the drift direction of each sensor would be opposite to each other, which leads to a rough canceling out of them due to the same sensor hardware being used. There are specifics to the implementation that I am not clear on, but it is a possiblity to be added in future versions.</p>
<h3 id='twheel_odom_rotation'>TWheel_odom_rotation</h3>
<blockquote>
<p>Prototype</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code>  <span class="n">TWheel_odom_rotation</span><span class="p">(</span><span class="n">TWheel</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">TWheel</span><span class="o">*</span> <span class="n">R</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dist_btwn</span><span class="p">)</span>
</code></pre></div>
<blockquote>
<p>Example</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code>  <span class="c1">//TWheel is an abstract class. You should be using the constructor of specific TWheels</span>
  <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel</span><span class="o">*</span> <span class="n">leftwheel</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">TWheel_Motor</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">E_MOTOR_GEARSET_18</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span> <span class="mf">2.75</span><span class="p">);</span> <span class="c1">//V5 motor, 200RPM, reversed, 2.75in wheel</span>

  <span class="c1">//For information on TWheel, please see the TWheel section of the site.</span>
  <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel</span><span class="o">*</span> <span class="n">rightwheel</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">TWheel_RotationSensor</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">//V5 rotation sensor, not reversed, 4in wheel</span>
  <span class="c1">//note that we are making TWheel* (TWheel pointers), not TWheels.</span>

  <span class="n">greatapi</span><span class="o">::</span><span class="n">odometry</span><span class="o">::</span><span class="n">TWheel_odom_rotation</span> <span class="n">example</span> <span class="o">=</span> <span class="o">*</span><span class="k">new</span> <span class="nf">TWheel_odom_rotation</span><span class="p">(</span><span class="n">leftwheel</span><span class="p">,</span><span class="n">rightwheel</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span> <span class="c1">//15 inches between</span>

  <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
    <span class="n">SRAD</span> <span class="n">currentangle</span> <span class="o">=</span> <span class="n">example</span><span class="p">.</span><span class="n">get_heading</span><span class="p">();</span> <span class="c1">//get current heading</span>
    <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">currentangle</span><span class="p">);</span> <span class="c1">//print angle on terminal</span>
    <span class="n">pros</span><span class="o">::</span><span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//10ms delay</span>
  <span class="p">}</span>
</code></pre></div>
<p><code>TWheel_odom_rotation</code> provides rotational odometry through usage of two parallel wheels mounted onto some type encoder.</p>

<aside class = 'warning'>
It must be noted that TWheel objects must be constructed with the new keyword, in order to ensure that they exist in memory. The constructor takes TWheels in pointer form, meaning that you need to make TWheel* pointers instead of TWheels. The positive direction of travel must be forwards in your TWheel constructors.
</aside>

<p>By comparing the traveled distances between two parallel wheels, it is possible to determine the relative distance from their starting orientations. We can logically explain this by noting that two parallel wheels will always traverse the same distance in translations. Therefore, any difference in their travel must be from rotations. </p>

<p>The mathematical expression to determine this distance is the following:</p>

<p><strong>Angle from start(in radians) = (distance of right wheel - distance of left wheel) / (distance between wheels)</strong> </p>

<p>This yields positive angles for CCW rotations, and negative angles for CW rotations.</p>

<aside class = 'notice'>
The wheels can be mounted anywhere on the robot, even asymetrically, as long as they are parallel. The <code>dist_btwn</code> parameter needs the distance between the wheels only in the axis perpendicular to the travel direction of the wheel.
</aside>
<h1 id='errors'>Errors</h1>
<aside class="notice">
This error section is stored in a separate file in <code>includes/_errors.md</code>. Slate allows you to optionally separate out your docs into many files...just save them to the <code>includes</code> folder and add them to the top of your <code>index.md</code>'s frontmatter. Files are included in the order listed.
</aside>

<p>The Kittn API uses the following error codes:</p>

<table><thead>
<tr>
<th>Error Code</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>400</td>
<td>Bad Request -- Your request is invalid.</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized -- Your API key is wrong.</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden -- The kitten requested is hidden for administrators only.</td>
</tr>
<tr>
<td>404</td>
<td>Not Found -- The specified kitten could not be found.</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed -- You tried to access a kitten with an invalid method.</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable -- You requested a format that isn&#39;t json.</td>
</tr>
<tr>
<td>410</td>
<td>Gone -- The kitten requested has been removed from our servers.</td>
</tr>
<tr>
<td>418</td>
<td>I&#39;m a teapot.</td>
</tr>
<tr>
<td>429</td>
<td>Too Many Requests -- You&#39;re requesting too many kittens! Slow down!</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error -- We had a problem with our server. Try again later.</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable -- We&#39;re temporarily offline for maintenance. Please try again later.</td>
</tr>
</tbody></table>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="cpp">cpp</a>
          </div>
      </div>
    </div>
  </body>
</html>
