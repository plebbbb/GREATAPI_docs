
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Reference</title>

    <style media="screen">
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cpf {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s, .highlight .sa, .highlight .dl {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf, .highlight .fm {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv, .highlight .vm {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .nl {
  color: #f92672;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <style media="print">
      * {
        -webkit-transition:none!important;
        transition:none!important;
      }
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #586e75;
}
.highlight .err {
  color: #002b36;
  background-color: #dc322f;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cm, .highlight .cpf, .highlight .c1, .highlight .cs {
  color: #657b83;
}
.highlight .cp {
  color: #b58900;
}
.highlight .nt {
  color: #b58900;
}
.highlight .o, .highlight .ow {
  color: #93a1a1;
}
.highlight .p, .highlight .pi {
  color: #93a1a1;
}
.highlight .gi {
  color: #859900;
}
.highlight .gd {
  color: #dc322f;
}
.highlight .gh {
  color: #268bd2;
  background-color: #002b36;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #6c71c4;
}
.highlight .kc {
  color: #cb4b16;
}
.highlight .kt {
  color: #cb4b16;
}
.highlight .kd {
  color: #cb4b16;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .dl, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #859900;
}
.highlight .sa {
  color: #6c71c4;
}
.highlight .sr {
  color: #2aa198;
}
.highlight .si {
  color: #d33682;
}
.highlight .se {
  color: #d33682;
}
.highlight .nn {
  color: #b58900;
}
.highlight .nc {
  color: #b58900;
}
.highlight .no {
  color: #b58900;
}
.highlight .na {
  color: #268bd2;
}
.highlight .m, .highlight .mb, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mx {
  color: #859900;
}
.highlight .ss {
  color: #859900;
}
    </style>
    <link href="stylesheets/screen-c9d8fa83.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print-953e3353.css" rel="stylesheet" media="print" />
      <script src="javascripts/all-a9fde460.js"></script>

    <script>
      $(function() { setupCodeCopy(); });
    </script>
  </head>

  <body class="index" data-languages="[&quot;cpp&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar-cad8cdcb.png" alt="" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo-5cf4fa3a.png" class="logo" alt="" />
        <div class="lang-selector">
              <a href="#" data-language-name="cpp">cpp</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#introduction" class="toc-h1 toc-link" data-title="Introduction">Introduction</a>
          </li>
          <li>
            <a href="#installation" class="toc-h1 toc-link" data-title="Installation">Installation</a>
          </li>
          <li>
            <a href="#odometry" class="toc-h1 toc-link" data-title="Odometry">Odometry</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#rotational-odometry" class="toc-h2 toc-link" data-title="Rotational Odometry">Rotational Odometry</a>
                  </li>
                  <li>
                    <a href="#positional-odometry" class="toc-h2 toc-link" data-title="Positional Odometry">Positional Odometry</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#control-loops" class="toc-h1 toc-link" data-title="Control Loops">Control Loops</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#proportional-integral-and-derivative-controllers" class="toc-h2 toc-link" data-title="Proportional, Integral, and Derivative controllers">Proportional, Integral, and Derivative controllers</a>
                  </li>
                  <li>
                    <a href="#unified-control-loop" class="toc-h2 toc-link" data-title="Unified Control Loop">Unified Control Loop</a>
                  </li>
              </ul>
          </li>
      </ul>
        <ul class="toc-footer">
            <li><a href='https://www.stlrobotics.org/'>Go to our website</a></li>
            <li><a href='https://github.com/slatedocs/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='introduction'>Introduction</h1>
<p>Welcome to GREATAPI, a Vex Robotics library for the PROS API. </p>
<h1 id='installation'>Installation</h1>
<p>To install GREATAPI, head to our <a href="https://github.com/plebbbb/GREATAPI/releases">releases page</a> and download the lastest GREATAPI@{something}.zip.</p>

<p>Open up a console on the folder you&#39;ve downloaded GREATAPI to, and enter the following command:</p>

<p><code>
prosv5 conduct fetch greatapi@[whatever version we are on].zip
</code></p>

<p>From here, GREATAPI should be addable on the upgrade tab of the PROS editor. You may have to manually type in the name for it to be detected. If GREATAPI isn&#39;t there or you want to use vscode instead, open up a console in the directory of your PROS project(the folder with project.pros) and enter the following:</p>

<p><code>
prosv5 conduct apply greatapi
</code></p>
<h1 id='odometry'>Odometry</h1>
<p>GREATAPI provides multiple feature levels of odometry for different robot configurations.</p>
<h2 id='rotational-odometry'>Rotational Odometry</h2>
<p>The lowest feature level GREATAPI provides is rotation tracking via the <code>odom_rotation</code> class.</p>

<p>Various tracking approaches are supported by child classes of <code>odom_rotation</code></p>

<table><thead>
<tr>
<th>Class Name</th>
<th>Utlized Sensors</th>
<th>Required Measurements</th>
</tr>
</thead><tbody>
<tr>
<td>IMU_odom_rotation</td>
<td>1x V5 Inertial Sensor</td>
<td>Inertial drift compensation multiplier</td>
</tr>
<tr>
<td>DoubleIMU_odom_rotation</td>
<td>2x V5 Inertial Sensor</td>
<td>none</td>
</tr>
<tr>
<td>TWheel_odom_rotation</td>
<td>2x Wheel encoders(any type)</td>
<td>Distance between wheel encoders, wheel diameters</td>
</tr>
</tbody></table>

<aside class = "warning">
<code>TWheel_odom_rotation</code> has unique and specific restrictions. Please go to its section for more details.
</aside>

<p><code>odom_rotation</code> child classes provide two functions for the end user:</p>

<table><thead>
<tr>
<th>Function</th>
<th>Purpose</th>
<th>Output</th>
</tr>
</thead><tbody>
<tr>
<td>get_heading()</td>
<td>Returns absolute heading of robot from starting position</td>
<td><code>SRAD</code> angle object</td>
</tr>
<tr>
<td>applyOffset(SRAD real)</td>
<td>Calibrates odometry output to match that of the real angle</td>
<td>nothing</td>
</tr>
</tbody></table>

<aside class = "warning"> Note that <code>odom_rotation</code> itself does not provide any angle calculation capabilities. Please construct one of the availiable child class options instead when programming your robot.
</aside>
<h3 id='imu_odom_rotation'>IMU_odom_rotation</h3>
<blockquote>
<p>Prototype</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code>  <span class="n">IMU_odom_rotation</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">double</span> <span class="n">driftcompensationfac</span><span class="p">)</span>
</code></pre></div>
<blockquote>
<p>Example</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code>  <span class="n">greatapi</span><span class="o">::</span><span class="n">odometry</span><span class="o">::</span><span class="n">IMU_odom_rotation</span> <span class="nf">example</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mf">1.01</span><span class="p">);</span> <span class="c1">//IMU on port 15, 101% drift compensation factor</span>
  <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
    <span class="n">greatapi</span><span class="o">::</span><span class="n">SRAD</span> <span class="n">currentangle</span> <span class="o">=</span> <span class="n">example</span><span class="p">.</span><span class="n">get_heading</span><span class="p">();</span> <span class="c1">//get current heading</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">currentangle</span><span class="p">;</span> <span class="c1">//print angle on terminal</span>
    <span class="n">pros</span><span class="o">::</span><span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//10ms delay</span>
  <span class="p">}</span>
</code></pre></div>
<blockquote>
<p>The v5 IMU has an update period of 10ms. Checking more frequently than that will not yield different results.</p>
</blockquote>

<p><code>IMU_odom_rotation</code> is a basic wrapper for the vex IMU. </p>

<p>It provides the capability to counteract integration drift via an automatic scaling the calculated angle by a specific amount. </p>
<h3 id='integration-drift'>Integration drift</h3>
<p>Integration drift is a phenomenon commonly found in inertial sensors. Inertial sensors measure the acceleration, and angular velocity of the robot at any point in time. To convert these values into more useful measurements like speed, heading, or position, we must use a technique known as integration. While we don&#39;t know where the robot actually is with these sensor values, we can assume that it starts at some fixed state(like not moving). From there, we can convert our accelerations and angular velocities into velocity, position, and heading changes. These can be added to the previous calculated position to get the current position.</p>

<p>The problem with this approach is obvious - Inaccuracies cannot be removed, and can add up until the sensor is inaccurate.</p>

<p><alert class = 'notice'> 
Incidentally, this is why most vex libraries don&#39;t provide the feature to calculate position using the IMU. To get position data, one needs to compound in two layers(acceleration -&gt; velocity -&gt; position), meaning that any inaccuracy in velocity will indefinitely increase inaccuracy in position. Heading data only needs one compounding step(angular velocity -&gt; heading), so this infinite compounding situation doesn&#39;t occur.
</alert></p>

<p>A quick and quite dirty way of compensating for this is to just scale the total degrees traveled by a hard set multiplier. One can experimentally determine a multiplier just by spinning the robot a known amount of degrees, and then dividing the known value by the sensor reported angle. Spinning over 10 rotations is suggested to minimize inaccuracy in determining the real traveled angle of the robot.</p>

<p>The multiplier is to be put in as the <code>driftcompensationfac</code> parameter of the constructor.</p>
<h3 id='doubleimu_odom_rotation'>DoubleIMU_odom_rotation</h3>
<p>Supposedly, there is a method of canceling out inertial drift with the same model of sensor by flipping one over and averaging out their outputs. Somehow, the drift direction of each sensor would be opposite to each other, which leads to a rough canceling out of them due to the same sensor hardware being used. There are specifics to the implementation that I am not clear on, but it is a possiblity to be added in future versions.</p>
<h3 id='twheel_odom_rotation'>TWheel_odom_rotation</h3>
<blockquote>
<p>Prototype</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code>  <span class="n">TWheel_odom_rotation</span><span class="p">(</span><span class="n">TWheel</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">TWheel</span><span class="o">*</span> <span class="n">R</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dist_btwn</span><span class="p">)</span>
</code></pre></div>
<blockquote>
<p>Example</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code>  <span class="c1">//TWheel is an abstract class. You should be using the constructor of specific TWheels</span>
  <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel</span><span class="o">*</span> <span class="n">leftwheel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel_Motor</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">pros</span><span class="o">::</span><span class="n">E_MOTOR_GEARSET_18</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span> <span class="mf">2.75</span><span class="p">);</span> <span class="c1">//V5 motor, 200RPM, reversed, 2.75in wheel</span>

  <span class="c1">//For information on TWheel, please see the TWheel section of the site.</span>
  <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel</span><span class="o">*</span> <span class="n">rightwheel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel_RotationSensor</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">//V5 rotation sensor, not reversed, 4in wheel</span>
  <span class="c1">//note that we are making TWheel* (TWheel pointers), not TWheels.</span>

  <span class="n">greatapi</span><span class="o">::</span><span class="n">odometry</span><span class="o">::</span><span class="n">TWheel_odom_rotation</span> <span class="n">example</span> <span class="o">=</span> <span class="o">*</span><span class="k">new</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">odometry</span><span class="o">::</span><span class="n">TWheel_odom_rotation</span><span class="p">(</span><span class="n">leftwheel</span><span class="p">,</span><span class="n">rightwheel</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span> <span class="c1">//15 inches between</span>

  <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
    <span class="n">greatapi</span><span class="o">::</span><span class="n">SRAD</span> <span class="n">currentangle</span> <span class="o">=</span> <span class="n">example</span><span class="p">.</span><span class="n">get_heading</span><span class="p">();</span> <span class="c1">//get current heading</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">currentangle</span><span class="p">;</span> <span class="c1">//print angle on terminal</span>
    <span class="n">pros</span><span class="o">::</span><span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//10ms delay</span>
  <span class="p">}</span>
</code></pre></div>
<p><code>TWheel_odom_rotation</code> provides rotational odometry through usage of two parallel wheels mounted onto some type of encoder.</p>

<aside class = 'warning'>
TWheel objects must be constructed with the new keyword in order to ensure that they exist in memory as the class doesnt store them. The constructor takes TWheels in pointer form, meaning that you need to make TWheel* pointers instead of TWheels. The positive direction of travel must be forwards in your TWheel constructors.
</aside>

<p>By comparing the traveled distances between two parallel wheels, it is possible to determine the relative distance from their starting orientations. We can logically explain this by noting that two parallel wheels will always traverse the same distance in translations. Therefore, any difference in their travel must be from rotations. </p>

<p>The mathematical expression to determine this distance is the following:</p>

<p><strong>Angle from start(in radians) = (distance of right wheel - distance of left wheel) / (distance between wheels)</strong> </p>

<p>This yields positive angles for CCW rotations, and negative angles for CW rotations.</p>

<aside class = 'notice'>
The wheels can be mounted anywhere on the robot, even asymetrically, as long as they are parallel. The <code>dist_btwn</code> parameter needs the distance between the wheels only in the axis perpendicular to the travel direction of the wheel.
</aside>
<h2 id='positional-odometry'>Positional Odometry</h2>
<p>GREATAPI also provides the capability to determine the absolute position of a robot in all relevant axises for a vex game(X, Y, and heading)</p>

<blockquote>
<p>Prototype</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code>  <span class="n">greatapi</span><span class="o">::</span><span class="n">odometry</span><span class="o">::</span><span class="n">odometry</span><span class="p">(</span><span class="n">TWheel</span><span class="o">*</span> <span class="n">X</span><span class="p">,</span> <span class="n">distance</span> <span class="n">X_to_ctr</span><span class="p">,</span> <span class="n">TWheel</span><span class="o">*</span> <span class="n">Y</span><span class="p">,</span> <span class="n">distance</span> <span class="n">Y_to_ctr</span><span class="p">,</span> <span class="n">odom_rotation</span><span class="o">*</span> <span class="n">rotation</span><span class="p">)</span>
</code></pre></div>
<blockquote>
<p>Example</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code>    <span class="c1">//TWheel is an abstract class. You should be using the constructor of specific TWheels</span>
    <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel</span><span class="o">*</span> <span class="n">leftwheel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel_Motor</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">pros</span><span class="o">::</span><span class="n">E_MOTOR_GEARSET_18</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span> <span class="mf">2.75</span><span class="p">);</span> <span class="c1">//V5 motor, 200RPM, reversed, 2.75in wheel</span>

    <span class="c1">//For information on TWheel, please see the TWheel section of the site.</span>
    <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel</span><span class="o">*</span> <span class="n">rightwheel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel_RotationSensor</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">//V5 rotation sensor, not reversed, 4in wheel</span>
    <span class="c1">//note that we are making TWheel* (TWheel pointers), not TWheels.</span>

    <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel</span><span class="o">*</span> <span class="n">rearwheel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">TWheel_ADIEncoder</span><span class="p">(</span><span class="sc">'A'</span><span class="p">,</span><span class="sc">'B'</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="mf">2.75</span><span class="p">);</span> <span class="c1">//V4 rotation encoder, not reversed, 2.75in wheel</span>

    <span class="n">greatapi</span><span class="o">::</span><span class="n">odometry</span><span class="o">::</span><span class="n">TWheel_odom_rotation</span> <span class="n">example</span> <span class="o">=</span> <span class="o">*</span><span class="k">new</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">odometry</span><span class="o">::</span><span class="n">TWheel_odom_rotation</span><span class="p">(</span><span class="n">leftwheel</span><span class="p">,</span><span class="n">rightwheel</span><span class="p">,</span><span class="mi">15</span><span class="p">);</span> <span class="c1">//15 inches between the wheels</span>

    <span class="n">greatapi</span><span class="o">::</span><span class="n">odometry</span><span class="o">::</span><span class="n">odometry</span> <span class="nf">test</span><span class="p">(</span><span class="n">leftwheel</span><span class="p">,</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">inches</span><span class="p">(</span><span class="mf">7.5</span><span class="p">),</span> <span class="n">rearwheel</span><span class="p">,</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">inches</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">example</span><span class="p">);</span> 
  <span class="c1">//left wheel is 7.5in from center of rotation, rear wheel is 8 inches away.</span>

  <span class="n">greatapi</span><span class="o">::</span><span class="n">position</span> <span class="nf">location</span><span class="p">(</span><span class="n">greatapi</span><span class="o">::</span><span class="n">coord</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">SRAD</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span> <span class="c1">//the position object storing the location of our robot</span>

  <span class="c1">//this loop is probably the update pattern you would want to use for your projects.</span>
  <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span> 
        <span class="n">location</span> <span class="o">=</span> <span class="n">test</span><span class="p">.</span><span class="n">calculateposition</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">location</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">location</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">location</span><span class="p">.</span><span class="n">angle</span><span class="p">;</span> <span class="c1">//print X, Y and angle after each test</span>
    <span class="n">pros</span><span class="o">::</span><span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//10ms wait before updating position.</span>
    <span class="p">}</span>
</code></pre></div><h3 id='configuration'>Configuration</h3>
<p>Positional odometry requires a set of two tracking wheels, positioned 90 degrees away from each other, as well as any valid <code>odom_rotation</code> object. In addition, the distance of each tracking wheel from the center of rotation of the robot is required.</p>

<aside class = "notice">
The same wheel encoder can be used for both <code>odom_rotation</code> and <code>odometry</code>. A pure wheel encoder setup only needs 3 wheel encoders.
</aside>
<h4 id='tbd-add-image-here-to-explain-config'>TBD: ADD IMAGE HERE TO EXPLAIN CONFIG</h4>
<p><code>odom_rotation</code> child classes provide a single function for the end user:</p>

<table><thead>
<tr>
<th>Function</th>
<th>Purpose</th>
<th>Output</th>
</tr>
</thead><tbody>
<tr>
<td>calculateposition(position initial)</td>
<td>Returns absolute position and heading of robot</td>
<td><code>position</code> object</td>
</tr>
</tbody></table>
<h4 id='tbd-explain-how-it-works'>TBD: EXPLAIN HOW IT WORKS</h4><h1 id='control-loops'>Control Loops</h1>
<p>GREATAPI provides PID control loops to assist you in developing PID control systems for your robot. </p>
<h2 id='proportional-integral-and-derivative-controllers'>Proportional, Integral, and Derivative controllers</h2>
<blockquote>
<p>Prototype</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code><span class="k">struct</span> <span class="nc">Proportional</span><span class="o">:</span> <span class="k">public</span> <span class="n">controlelement</span><span class="p">{</span>
    <span class="kt">double</span> <span class="n">maxcap</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">mincap</span><span class="p">;</span>
    <span class="n">Proportional</span><span class="p">(</span><span class="kt">double</span> <span class="n">fac</span><span class="p">)</span><span class="o">:</span><span class="n">controlelement</span><span class="p">(</span><span class="n">fac</span><span class="p">){</span>
        <span class="n">mincap</span> <span class="o">=</span> <span class="n">__DBL_MIN__</span><span class="p">;</span>
        <span class="n">maxcap</span> <span class="o">=</span> <span class="n">__DBL_MAX__</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Proportional</span><span class="p">(</span><span class="kt">double</span> <span class="n">fac</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">caps</span><span class="p">)</span><span class="o">:</span><span class="n">controlelement</span><span class="p">(</span><span class="n">fac</span><span class="p">){</span>
        <span class="n">maxcap</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">caps</span><span class="p">);</span>
        <span class="n">mincap</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">caps</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">//standard offset format: target-current. This class assumes the offset is in the correct direction already</span>
    <span class="kt">double</span> <span class="n">compute</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">current</span><span class="p">){</span>
        <span class="kt">double</span> <span class="n">rawval</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span><span class="o">-</span><span class="n">current</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">returnval</span> <span class="o">=</span> <span class="n">factor</span><span class="o">*</span><span class="n">rawval</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">returnval</span> <span class="o">&lt;=</span> <span class="n">maxcap</span><span class="p">)</span> <span class="o">?</span> <span class="p">((</span><span class="n">returnval</span> <span class="o">&gt;=</span> <span class="n">mincap</span><span class="p">)</span> <span class="o">?</span> <span class="n">returnval</span> <span class="o">:</span> <span class="n">mincap</span><span class="p">)</span> <span class="o">:</span> <span class="n">maxcap</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Integral</span><span class="o">:</span> <span class="k">public</span> <span class="n">controlelement</span><span class="p">{</span>
    <span class="kt">double</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">maxcap</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">mincap</span><span class="p">;</span>

    <span class="c1">//this is NOT recommended due to integral windup</span>
    <span class="n">Integral</span><span class="p">(</span><span class="kt">double</span> <span class="n">fac</span><span class="p">)</span><span class="o">:</span><span class="n">controlelement</span><span class="p">(</span><span class="n">fac</span><span class="p">){</span>
        <span class="n">mincap</span> <span class="o">=</span> <span class="n">__DBL_MIN__</span><span class="p">;</span>
        <span class="n">maxcap</span> <span class="o">=</span> <span class="n">__DBL_MAX__</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Integral</span><span class="p">(</span><span class="kt">double</span> <span class="n">fac</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">caps</span><span class="p">)</span><span class="o">:</span><span class="n">controlelement</span><span class="p">(</span><span class="n">fac</span><span class="p">){</span>
        <span class="n">maxcap</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">caps</span><span class="p">);</span>
        <span class="n">mincap</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">caps</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">//standard offset format: target-current. This class assumes the offset is in the correct direction already</span>
    <span class="kt">double</span> <span class="n">compute</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">current</span><span class="p">){</span>
        <span class="k">if</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">target</span> <span class="o">==</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">current</span><span class="p">)</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">rawval</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span><span class="o">-</span><span class="n">current</span><span class="p">);</span>
        <span class="n">last</span> <span class="o">+=</span> <span class="n">rawval</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">returnval</span> <span class="o">=</span> <span class="n">last</span><span class="o">*</span><span class="n">factor</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">returnval</span> <span class="o">&lt;=</span> <span class="n">maxcap</span><span class="p">)</span> <span class="o">?</span> <span class="p">((</span><span class="n">returnval</span> <span class="o">&gt;=</span> <span class="n">mincap</span><span class="p">)</span> <span class="o">?</span> <span class="n">returnval</span> <span class="o">:</span> <span class="n">mincap</span><span class="p">)</span> <span class="o">:</span> <span class="n">maxcap</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Derivative</span><span class="o">:</span> <span class="k">public</span> <span class="n">controlelement</span><span class="p">{</span>
    <span class="kt">double</span> <span class="n">past</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">maxcap</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">mincap</span><span class="p">;</span>
    <span class="n">Derivative</span><span class="p">(</span><span class="kt">double</span> <span class="n">fac</span><span class="p">)</span><span class="o">:</span><span class="n">controlelement</span><span class="p">(</span><span class="n">fac</span><span class="p">){</span>
        <span class="n">mincap</span> <span class="o">=</span> <span class="n">__DBL_MIN__</span><span class="p">;</span>
        <span class="n">maxcap</span> <span class="o">=</span> <span class="n">__DBL_MAX__</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Derivative</span><span class="p">(</span><span class="kt">double</span> <span class="n">fac</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">caps</span><span class="p">)</span><span class="o">:</span><span class="n">controlelement</span><span class="p">(</span><span class="n">fac</span><span class="p">){</span>
        <span class="n">maxcap</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">caps</span><span class="p">);</span>
        <span class="n">mincap</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">caps</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">//standard offset format: target-current. This class assumes the offset is in the correct direction already</span>
      <span class="kt">double</span> <span class="n">compute</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">current</span><span class="p">){</span>
          <span class="kt">double</span> <span class="n">rawval</span> <span class="o">=</span> <span class="n">target</span><span class="o">-</span><span class="n">current</span><span class="p">;</span>
          <span class="kt">double</span> <span class="n">returnval</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">rawval</span><span class="o">-</span><span class="n">past</span><span class="p">);</span>
          <span class="n">past</span> <span class="o">=</span> <span class="n">rawval</span><span class="p">;</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">returnval</span> <span class="o">&lt;=</span> <span class="n">maxcap</span><span class="p">)</span> <span class="o">?</span> <span class="p">((</span><span class="n">returnval</span> <span class="o">&gt;=</span> <span class="n">mincap</span><span class="p">)</span> <span class="o">?</span> <span class="n">returnval</span> <span class="o">:</span> <span class="n">mincap</span><span class="p">)</span> <span class="o">:</span> <span class="n">maxcap</span><span class="p">;</span>
      <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>The controllers GREATAPI offers are separate P, I, and D controllers throught the <code>controlelement</code> class. 
Each of the three controllers have their own child class of controlelement. </p>

<table><thead>
<tr>
<th>Class Name</th>
</tr>
</thead><tbody>
<tr>
<td>Proportional</td>
</tr>
<tr>
<td>Integral</td>
</tr>
<tr>
<td>Derivative</td>
</tr>
</tbody></table>

<p><code>controlelement</code> child classes provide one function to the user: </p>

<table><thead>
<tr>
<th>Function</th>
<th>Parameters</th>
<th>Purpose</th>
</tr>
</thead><tbody>
<tr>
<td>compute(double target, double current)</td>
<td>Target value and current value</td>
<td>Returns the corresponding component of the control loop</td>
</tr>
</tbody></table>

<aside class = "warning">
Note that <code>controlelement</code> itself does not compute any outputs. Please contruct one of the available child classes instead when programming your robot.  
</aside>
<h3 id='proportional-controller'>Proportional controller</h3><h2 id='unified-control-loop'>Unified Control Loop</h2>
<blockquote>
<p>Prototype</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code><span class="c1">//Modular control loop, computes values for a set of control elements</span>
<span class="k">struct</span> <span class="nc">control_loop</span><span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">controlelement</span><span class="o">*&gt;</span> <span class="n">elementset</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">maxcap</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">mincap</span><span class="p">;</span>
    <span class="c1">//if you dont like caps just set them really high, like +-INT_MAX or something</span>
    <span class="n">control_loop</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">controlelement</span><span class="o">*&gt;</span> <span class="n">val</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">caps</span><span class="p">)</span><span class="o">:</span><span class="n">elementset</span><span class="p">(</span><span class="n">val</span><span class="p">){</span>
        <span class="n">maxcap</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">caps</span><span class="p">);</span>
        <span class="n">mincap</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">caps</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">double</span> <span class="n">update</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">current</span><span class="p">){</span>
        <span class="kt">double</span> <span class="n">returnval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">//no enhanced for to minimize risk of sketchy copying issues</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">elementset</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">returnval</span> <span class="o">+=</span> <span class="n">elementset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">compute</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="n">current</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">returnval</span> <span class="o">&lt;=</span> <span class="n">maxcap</span><span class="p">)</span> <span class="o">?</span> <span class="p">((</span><span class="n">returnval</span> <span class="o">&gt;=</span> <span class="n">mincap</span><span class="p">)</span> <span class="o">?</span> <span class="n">returnval</span> <span class="o">:</span> <span class="n">mincap</span><span class="p">)</span> <span class="o">:</span> <span class="n">maxcap</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<blockquote>
<p>Example</p>
</blockquote>
<div class="highlight"><pre class="highlight cpp tab-cpp"><code><span class="c1">//create the new controlelements</span>
<span class="n">greatapi</span><span class="o">::</span><span class="n">controlelement</span> <span class="o">*</span><span class="n">PPos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">Proportional</span><span class="p">(</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="p">(</span><span class="n">__DBL_MAX__</span><span class="p">,</span> <span class="n">__DBL_MIN__</span><span class="p">));</span>
<span class="n">greatapi</span><span class="o">::</span><span class="n">controlelement</span> <span class="o">*</span><span class="n">IPos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">Integral</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="p">(</span><span class="n">__DBL_MAX__</span><span class="p">,</span> <span class="n">__DBL_MIN__</span><span class="p">));</span>
<span class="n">greatapi</span><span class="o">::</span><span class="n">controlelement</span> <span class="o">*</span><span class="n">DPos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">greatapi</span><span class="o">::</span><span class="n">Derivative</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="p">(</span><span class="n">__DBL_MAX__</span><span class="p">,</span> <span class="n">__DBL_MIN__</span><span class="p">));</span>

<span class="c1">//add the controlements to a new std::vector</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">greatapi</span><span class="o">::</span><span class="n">controlelement</span> <span class="o">*&gt;</span> <span class="n">PIDPosElements</span><span class="p">;</span>
<span class="n">PIDPosElements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PPos</span><span class="p">);</span>
<span class="n">PIDPosElements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">IPos</span><span class="p">);</span>
<span class="n">PIDPosElements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DPos</span><span class="p">);</span>

<span class="c1">//Create the control_loop unified control loop</span>
<span class="n">greatapi</span><span class="o">::</span><span class="n">control_loop</span> <span class="nf">PIDPos</span><span class="p">(</span><span class="n">PIDPosElements</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="p">(</span><span class="n">INT32_MAX</span><span class="p">,</span> <span class="n">INT32_MIN</span><span class="p">));</span>
</code></pre></div>
<p>The Unified Control Loop computes the final outputs for a PID controller with any amount of P, I, and D <code>controllerelements</code> by summing their outputs together.</p>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="cpp">cpp</a>
          </div>
      </div>
    </div>
  </body>
</html>
